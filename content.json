{"meta":{"title":"kayleeWei","subtitle":null,"description":"learning FE","author":"kayleeWei","url":"https://kayleeWei.github.io","root":"/"},"pages":[{"title":"404","date":"2019-09-09T03:17:10.994Z","updated":"2019-09-09T03:17:10.994Z","comments":true,"path":"404.html","permalink":"https://kayleeWei.github.io/404.html","excerpt":"","text":""},{"title":"about","date":"2019-09-06T04:56:50.000Z","updated":"2019-09-09T03:17:10.993Z","comments":true,"path":"about/index.html","permalink":"https://kayleeWei.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"解决ios浏览器中click点击后页面闪动的问题","slug":"解决ios浏览器中click点击后页面闪动的问题","date":"2019-12-09T06:49:30.000Z","updated":"2019-12-09T06:51:04.972Z","comments":true,"path":"2019/12/09/解决ios浏览器中click点击后页面闪动的问题/","link":"","permalink":"https://kayleeWei.github.io/2019/12/09/解决ios浏览器中click点击后页面闪动的问题/","excerpt":"","text":"解决ios浏览器中click点击后页面闪动的问题现象：在ios浏览器中的页面，点击页面后出现dom背景闪动（灰色半透明的背景） 解决方法：为闪动dom添加以下css解决， 将ios默认点击交互效果的透明度设为0 12345.class&#123; -webkit-tap-highlight-color:transparent; //方法一 -webkit-tap-highlight-color: rgba(0, 0, 0, 0); //方法二 tap-highlight-color: rgba(0, 0, 0, 0);//方法三&#125;","categories":[{"name":"FE","slug":"FE","permalink":"https://kayleeWei.github.io/categories/FE/"}],"tags":[{"name":"ios","slug":"ios","permalink":"https://kayleeWei.github.io/tags/ios/"}]},{"title":"部分浏览器在post请求头部添加origin: null","slug":"post请求头部origin-null踩坑","date":"2019-09-10T11:51:46.000Z","updated":"2019-09-11T02:24:01.189Z","comments":true,"path":"2019/09/10/post请求头部origin-null踩坑/","link":"","permalink":"https://kayleeWei.github.io/2019/09/10/post请求头部origin-null踩坑/","excerpt":"","text":"现象描述：在部分安卓手机的UC浏览器、QQ浏览器和自带浏览器中，当发起post请求时，浏览器会自动给请求头部增加origin: null，而后端出于安全考虑，无法处理origin：null的请求导致请求失败。 解决方法：方法一：在client和server之间加一层请求转发，以node为例，通过node层转发java请求在node层转发java请求时，手动增加origin: ‘xxx’字段，以express为例： 1234567891011121314151617181920212223242526// node层router.post(`/api/*`, async (req, res) =&gt; &#123; const url = req.originalUrl.substring(req.originalUrl.indexOf(`/api/`) + 5); const cookies = req.cookies; const resp = await fetch('xxxx(请求的url)', &#123; method: 'post', body: queryString.stringify(Object.assign(&#123;&#125;, req.body)), headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded', origin: 'https://xxx(需要设置的origin)', // 添加origin cookie: Object.keys(cookies).map(c =&gt; `$&#123;c&#125;=$&#123;cookies[c]&#125;`).join(';'), &#125;, &#125;); const retJson = await resp.json(); res.send(retJson);&#125;)// 请求node接口const req = fetch(`$&#123;当前前端域名&#125;/api/$&#123;接口名&#125;`, &#123; method: 'POST', ...&#125;)req.then((res) =&gt; &#123; ...&#125;) 从安全角度考虑，不推荐从node层转发时添加origin方法，可参考方法二 方法二：请求java API时请求头部增加referrerPolicy: ‘origin’为什么有些浏览器会将origin设置为null呢？根据fetch文档，如果请求不是get或者head，则referrerPolicy设置为’no-referrer’时。会将origin设置为null，因此将referrerPolicy设置为’origin’，就不会出现origin：null的情况，解决方法如下： 123456// 请求java APIconst req = fetch(`$&#123;java API&#125;`, &#123; method: 'POST', referrerPolicy: 'origin', ...&#125;)","categories":[{"name":"FE","slug":"FE","permalink":"https://kayleeWei.github.io/categories/FE/"}],"tags":[{"name":"post","slug":"post","permalink":"https://kayleeWei.github.io/tags/post/"},{"name":"fetch","slug":"fetch","permalink":"https://kayleeWei.github.io/tags/fetch/"},{"name":"origin","slug":"origin","permalink":"https://kayleeWei.github.io/tags/origin/"},{"name":"referrerPolicy","slug":"referrerPolicy","permalink":"https://kayleeWei.github.io/tags/referrerPolicy/"}]},{"title":"当input标签的maxlength属性遇上emoji","slug":"input标签的maxlength","date":"2019-09-06T06:25:42.000Z","updated":"2019-09-09T03:17:10.993Z","comments":true,"path":"2019/09/06/input标签的maxlength/","link":"","permalink":"https://kayleeWei.github.io/2019/09/06/input标签的maxlength/","excerpt":"","text":"限制输入框的字数是一个很常见的需求，我们常常使用input/textarea标签的maxlength属性来限制输入字数。但当用户输入emoji字符时，在不同端中maxlength属性计算出的emoji长度却不一致。js和安卓上一个emoji都算作2个字符长度，而在ios上为1个字符长度。 用js而非maxlength限制字数为了让限制字数在不同端上得到统一，可以用js限制字数取代maxlength属性，使用扩展运算符将输入字符串都转为数组计算长度，这样emoji在不同端长度都是1： 123const inputValue = '👿😄other';const inputArr = [...inputValue]; // [\"👿\", \"😄\", \"o\", \"t\", \"h\", \"e\", \"r\"]console.log(inputArr.length) // 7 当超出限制长度时，我们就将字符串截断（slice等操作），只展示限制字数内的内容。 使用js限制输入长度带来的问题使用中文输入法时的字符截断问题但用js限制长度时，会出现如图问题： 假设限制长度为2，我们想输入“例子”这两个字，在使用中文输入法时“li”处就会判断已经达到2个字符，因此在输入域内只能展示“li”，不能继续输入。 解决办法 — compositionEvent使用compositionEvent事件来监听中文输入的过程，compositionEvent包含3个事件： compositionStart：输入开始 compositionUpdate：输入变化，没有点选中文之前触发多次 compositionEnd：点选中文，输入结束 我们可以监听compositionStart和compositionEnd事件，设置一个标志位表示用户是否正在输入。如果正在输入，就不判断是否超出限制长度，等输入完毕再根据限制长度截取字符串。 Example123456789101112131415161718192021222324252627282930313233handleChange = (e, limitNum) =&gt; &#123; const valueArr = [...event.target.value]; const isSlice = valueArr.length &gt; limitNum &amp;&amp; this.isComposing; this.setState(&#123; text: isSlice ? valueArr.join('') : valueArr.slice(0, limitNum).join('') &#125;);&#125; // 监听输入法onComposition = (e) =&gt; &#123; if (e.type === 'compositionstart') &#123; this.isComposing = true; &#125; else if (e.type === 'compositionend') &#123; // 停止输入时截取限定长度的字符串 this.isComposing = false; this.setState(&#123; text: [...this.state.text].slice(0, limitNum).join(''), &#125;) &#125;&#125; render() &#123; const &#123; text &#125; = this.state; ... return ( &lt;textarea value=&#123;text&#125; onChange=&#123;(e) =&gt; this.handleChange(e, limitNum)&#125; onCompositionStart=&#123;(e) =&gt; this.onComposition(e, limitNum)&#125; onCompositionEnd=&#123;(e) =&gt; this.onComposition(e, limitNum)) /&gt; )&#125;","categories":[{"name":"FE","slug":"FE","permalink":"https://kayleeWei.github.io/categories/FE/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://kayleeWei.github.io/tags/HTML/"},{"name":"react","slug":"react","permalink":"https://kayleeWei.github.io/tags/react/"}]}]}